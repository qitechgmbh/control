Index: machines/src/ethercat_beckhoff/act.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use super::BeckhoffMachine;\nuse crate::{MachineAct, MachineMessage};\nuse std::time::Instant;\n\n\n\nimpl MachineAct for BeckhoffMachine {\n    fn act(&mut self, _now_ts: Instant) {\n        if let Ok(msg) = self.api_receiver.try_recv() {\n            self.act_machine_message(msg);\n        }\n\n        self.motor_driver.set_enabled(self.motor_state.enabled);\n\n        if self.motor_state.enabled {\n\n            let steps_per_rev = 200.0; // Anpassen an deinen Motor!\n            let steps_per_second = (self.motor_state.target_velocity as f64)\n                * steps_per_rev / 60.0;\n\n            let _ = self.motor_driver.set_speed(steps_per_second);\n        } else {\n            let _ = self.motor_driver.set_speed(0.0);\n        }\n    }\n\n    fn act_machine_message(&mut self, msg: MachineMessage) {\n        match msg {\n            MachineMessage::SubscribeNamespace(ns) => {\n                self.namespace.namespace = Some(ns);\n                self.emit_state();\n            },\n            MachineMessage::UnsubscribeNamespace => {\n                self.namespace.namespace = None;\n            },\n            MachineMessage::HttpApiJsonRequest(value) => {\n                use crate::MachineApi;\n                let _ = self.api_mutate(value);\n            },\n            _ => {}\n        }\n    }\n}
===================================================================
diff --git a/machines/src/ethercat_beckhoff/act.rs b/machines/src/ethercat_beckhoff/act.rs
--- a/machines/src/ethercat_beckhoff/act.rs	(revision 6af2548baf4a97384bea3431e4226299ced548b2)
+++ b/machines/src/ethercat_beckhoff/act.rs	(date 1765183449698)
@@ -14,7 +14,7 @@
 
         if self.motor_state.enabled {
 
-            let steps_per_rev = 200.0; // Anpassen an deinen Motor!
+            let steps_per_rev = 200.0;
             let steps_per_second = (self.motor_state.target_velocity as f64)
                 * steps_per_rev / 60.0;
 
Index: machines/src/ethercat_beckhoff/new.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use crate::{\n    MachineNewHardware, MachineNewParams, MachineNewTrait, get_ethercat_device,\n    validate_no_role_dublicates, validate_same_machine_identification_unique,\n};\nuse super::{BeckhoffMachine, MotorState, api::BeckhoffNamespace};\nuse anyhow::Error;\n\nuse ethercat_hal::devices::{\n    ek1100::{EK1100, EK1100_IDENTITY_A},\n    // WICHTIG: EL7031_IDENTITY_B hier oben mit importieren!\n    el7031::{EL7031, EL7031_IDENTITY_A, EL7031_IDENTITY_B, EL7031StepperPort},\n    el7031::coe::EL7031Configuration,\n    el7031::pdo::EL7031PredefinedPdoAssignment,\n};\nuse ethercat_hal::shared_config;\nuse ethercat_hal::shared_config::el70x1::{EL70x1OperationMode, StmMotorConfiguration};\nuse ethercat_hal::io::stepper_velocity_el70x1::StepperVelocityEL70x1;\nuse ethercat_hal::coe::ConfigurableDevice;\n\nimpl MachineNewTrait for BeckhoffMachine {\n    fn new<'maindevice>(params: &MachineNewParams) -> Result<Self, Error> {\n        let device_identification = params.device_group.iter().cloned().collect::<Vec<_>>();\n        validate_same_machine_identification_unique(&device_identification)?;\n        validate_no_role_dublicates(&device_identification)?;\n\n        let hardware = match &params.hardware {\n            MachineNewHardware::Ethercat(x) => x,\n            _ => return Err(anyhow::anyhow!(\"Hardware is not EtherCAT\")),\n        };\n\n        smol::block_on(async {\n            // Role 0: EK1100 (Koppler)\n            let _ek1100 = get_ethercat_device::<EK1100>(\n                hardware, params, 0, vec![EK1100_IDENTITY_A]\n            ).await?;\n\n            // Role 1: EL7031 (Stepper Motor)\n            let el7031 = {\n                let device = get_ethercat_device::<EL7031>(\n                    hardware,\n                    params,\n                    1,\n                    vec![EL7031_IDENTITY_A, EL7031_IDENTITY_B],\n                ).await?;\n\n                let el7031_config = EL7031Configuration {\n                    stm_features: shared_config::el70x1::StmFeatures {\n                        operation_mode: EL70x1OperationMode::DirectVelocity,\n                        speed_range: shared_config::el70x1::EL70x1SpeedRange::Steps1000,\n                        ..Default::default()\n                    },\n                    stm_motor: StmMotorConfiguration {\n                        max_current: 1500,\n                        ..Default::default()\n                    },\n                    pdo_assignment: EL7031PredefinedPdoAssignment::VelocityControlCompact,\n                    ..Default::default()\n                };\n\n                device\n                    .0\n                    .write()\n                    .await\n                    .write_config(&device.1, &el7031_config)\n                    .await?;\n\n                device.0\n            };\n\n            let motor_driver = StepperVelocityEL70x1::new(\n                el7031.clone(),\n                EL7031StepperPort::STM1\n            );\n\n            let (sender, receiver) = smol::channel::unbounded();\n\n            Ok(Self {\n                main_sender: params.main_thread_channel.clone(),\n                api_receiver: receiver,\n                api_sender: sender,\n                machine_identification_unique: params.get_machine_identification_unique(),\n                namespace: BeckhoffNamespace { namespace: params.namespace.clone() },\n                motor_driver,\n                motor_state: MotorState { enabled: false, target_velocity: 0 },\n            })\n        })\n    }\n}
===================================================================
diff --git a/machines/src/ethercat_beckhoff/new.rs b/machines/src/ethercat_beckhoff/new.rs
--- a/machines/src/ethercat_beckhoff/new.rs	(revision 6af2548baf4a97384bea3431e4226299ced548b2)
+++ b/machines/src/ethercat_beckhoff/new.rs	(date 1765184427765)
@@ -81,7 +81,7 @@
                 machine_identification_unique: params.get_machine_identification_unique(),
                 namespace: BeckhoffNamespace { namespace: params.namespace.clone() },
                 motor_driver,
-                motor_state: MotorState { enabled: false, target_velocity: 0 },
+                motor_state: MotorState { enabled: true, target_velocity: 0 },
             })
         })
     }
